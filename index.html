<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Datastore Client APIs</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/dracula.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/vs2015.css">
		<style>
			.na_ish {
				opacity: 0.5;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section>
					<h1>Datastore<br>
						Client APIs</h1>
					<p>The app dev's datastore <br>
						ðŸ›’ shopping guide</p>
				</section>

				<section><!-- Overview -->
					<h3>Overview</h3>
					<ul>
						<li>What are Datastore Client APIs?</li>
						<li>Productivity & Tech Debt</li>
						<li>APIs grouped by main styles</li>
						<li>Pros and cons of features X, Y & Z ...</li>
						<li>Connection protocols</li>
						<li>Security</li>
					</ul>
				</section>

				<section><!-- What is a Datastore API? -->
					<h3>What is a Datastore API?</h3>
					<p class="fragment">Libraries you import/include in your program to interface with the external datastore</p>
					<ul class="fragment">
						<li>ODBC 'driver'</li>
						<li>NoSQL database or KV API</li>
						<li>HTTP REST API</li>
						<li>Embedded storage engine API</li>
						<li>Filesystem API</li>
						<li>etc.</li>
					</ul>
				</section>

				<section>
					<p>The API will include functions to:</p>
					<ul>
						<li>Open network connection to datastore</li>
						<li>Authenticate</li>
						<li>Query</li>
						<li>Insert/Update/Delete</li>
						<li>Iterate records</li>
					</ul>
					<p>... and more, varying according to the datastore.</p>
				</section>

				<section>
					<p>Old days: "Database driver"</p>
					<p>(Not true drivers though)</p>
					<p>Recently also called the following:</p>
					<ul>
						<li>Client library</li>
						<li>API</li>
						<li>&lt;Product name&gt; SDK</li>
					<aside class="notes">
						Not an OS kernel module that that manages a hardware device such as disk drives, network interface card, graphics, USB hub, etc.
					</aside>
				</section>

				<section data-auto-animate><!-- Gruen Effect -->
					<h2>The Gruen Effect</h2>
					<h4 data-auto-animate-id="gest">...</h4>
					<p data-auto-animate-id="geq">Consumers enter a shopping mall or store and, surrounded by an intentionally confusing layout, lose track of their original intentions, making them more susceptible to making impulse buys</p>
				</section>

				<section data-auto-animate><!-- Gruen Effect -->
					<h2>The Gruen Effect</h2>
					<h4 data-auto-animate-id="gest">Software Architecture Edition</h4>
					<p data-auto-animate-id="geq">Developers search the web and, surrounded by a confusing array of options, lose track of their original requirements, making them susceptible to accepting whatever solution they browsed last.</p>
				</section>

				<section>
					<h1>Productivity & Tech Debt</h1>
				</section>
				<section>
					<h2>Developer (un)productivity</h2>
					<p>No matter which app, the purpose and style of the application's code is not the same as the interface of datastore's API. This friction breaks the developer's concentration and slows the release time of every update that changes the datastore interaction.â€‹</p>
				</section>
				<section>
					<p>The disruption level varies according to which API is being used.</p>
					<p>Some APIs are simple, and close to an application programming language's normal conventions.</p>
					<p>Others are their own rich, separate domain to the application.</p>
				</section>
				<section>
					<h2>Technical debt</h2>
					<p>If you use it, you require other developers to have or pick up the same knowledge about it before they can contribute.</p>
				</section>
				<section>
					<p>Pick the datastore with the best client API for your staff and application requirements<br>
						=<br>
						Development and release cycle is faster each time</p>
				</section>
				<section>
					<p>Picking the simplest client API that meets requirements<br>
						=<br>
						Lower application tech debt in future</p>
				</section>

				<section><!-- Styles of Datastore APIs -->
					<h1>Grouping APIs by 'Look and feel'</h1>
				</section>

				<section>
					<h2>Main styles of Datastore APIs</h2>
					<ul style="display: inline-block">
						<li>SQL, Relational</li>
						<li>Document databases</li>
						<li>Object stores</li>
						<li>Spartan Key-Value</li>
						<li>Timeseries</li>
					</ul>
					<ul style="display: inline-flexbox">
						<li>Search Engines</li>
						<li>Graph</li>
						<li>Native container wrappers</li>
						<li>Embedded storage engine</li>
						<li>Filesystem</li>
					</ul>
				</section>

				<section>
					<h2>&hellip; plus the 'Mashups'</h2>
				</section>

				<section>
					<h2>Multi-model</h2>
					<p>Mixtures of the previous types served by the same datastore and competing client APIs.</p>
					<p>Eg. App A needs to use SQL but App B is easier to program if records handled as JSON objects.</p>
				</section>
				<section>
					<h2>Competing APIs</h2>
					<p>Example for MySQL by ODBC</p>
					<pre><code data-trim>
						db_conn = pyodbc.connect("Server=....;Database=test;....")
						cursor = db_conn.cursor()
						cursor.execute(
							"INSERT INTO my_table (name, dim_x) VALUES (?, ?)", 
							"foo", 19)
					</code></pre>
					<p>&hellip; vs X DevAPI</p>
					<pre><code data-trim>
						mySession = mysqlx.get_session({"host": ..., ...  })
						myDb = mySession.get_schema('test')
						myColl = myDb.get_collection('my_table')
						myColl.add({ 'name': 'foo', 'dim_x': 19 }).execute()
					</code></pre>
				</section>
				<section>
					<h2>A lot of "A little bit of this in that"</h2>
					<p>Without identifying as a multi-model many datastores have glued-on, often awkward extra APIs for interfaces of another family. Examples: JSON field type in a relational db; SQL-like table join function in an object db; Graph queries; pub/sub or streaming APIs; etc.â€‹</p>
					<p>Some of the out-of-family, extra API additions are not so awkward. Example: Basic text search index as an extra index type for tables/collections with string fields.</p>
				</section>

				<section><!-- SQL -->
					<section>
						<h1>SQL</h1>
					</section>
					<section>
						<pre><code>
							import xyz_db_lib
							conn = xyz_db_lib.connect(dbname=business_app_foo, user=appservice_acct_pqr)
							cur = conn.cursor()
							// DBA prior task: "CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);" â‘ â€‹
							cur.execute("INSERT INTO test (num, data) VALUES (%s, %s)", (100, "abcdef")) â‘¡ â‘¢
							conn.commit() â‘£â€‹
							cur.execute("SELECT id, num, data FROM test;") â‘¤â€‹
							print(cur.fetchone())
							> (1, 100, "abcdef") â‘¥
						</code></pre>
						<aside class="notes">
							1.  GRANT CREATE TABLE â€¦ is usually only given to an account the DBA manually logs in with. The table object needs to be created first, and the expectations of the app must be in sync with what the table definition was made to be by the DBA.
							2. SQL statements are strings that will be parsed server-side. Strings that are a computer language, inside your application code in another programming language.
							3. So the app must format all vars into the string before sending, which is awkward code.
							4. Transactions are used more in relational databases because normalized form often puts one business object in several tables. Multi-table transactions drive the latency of one op for the client, and place concurrency-guaranteeing burdens in the db server. Transactions with writes can block other clients too.
							5. Again, SQL string in the middle of different language.
							6. To use the returned results is typically more verbose than this example. Column names and types are metadata of the cursor result. Records don't have the column names as keys in them. It can be the other way but the original style of the cursor API is like a table - fixed cols and types, rows are all tuples of those same types they don't need the metadata each.
						</aside>
					</section>
					<!-- section>
						<ul>
							<li>Programmer is obliged to learn SQL syntax and manage it, a separate language, as strings inside the application's actual programming language. CONTEXT SWITCH PENALTY.
								SQL is widely used, has a standard that no-one keeps perfectly but most are close. LINGUA FRANCA?
								Relational table concept is simple and appealing; suits a lot of cases.
								SQL is first intuitive and easy; quickly becomes non-intuitive beyond easy level.
								DB schema changes in the DBMS will require synchronous app version updates. MULTI-TEAM SYNCHRONIZATION NEEDED FOR SCHEMA MIGRATIONS.
								App programmer sees the DB as a rigid thing. POWERLESSNESS
								(Not shown) writing a generic function that dynamically accepts any table's record definitions is verbose and time-consuming to write, and hard to get right.
								Relational table normalized forms require multi-table operations within transactions.</li>
						</ul>
					</!-->
					<!-- section>
						<ul>
							<li>Complex, large aggregations can be done server-side.</li>
						</ul>
					</!-->
				</section>

				<section><!-- Doc DBs-->
					<section>
						<h1>Document Database</h1>
					</section>
					<section>
						<pre><code>
							import xyz_db_lib
							db = xyz_db_lib.connect(dbname=business_app_foo, user=appservice_acct_pqr)
							cr_array = [ "Xxx", "Yyy", "Zzz" ]
							x = { id: "HSD-10422932", child_recs: cr_array, created: date.now() } â‘ 
							db.foo_collection.insert(x) â‘¡ â‘¢â€‹
							print(db.bar_collection.findOne({ id: "SKE-54293450"})) â‘£â€‹
							> { id: "SKE-54293450", field_a: â€¦, field_b: â€¦. } â‘¤
						</code></pre>
						<aside class="notes">
							1. Native variable types of the programming language are used as-is (so long as they are a datatype in the db). No translation to another type needed. It's just your object, no transformation to a record type is required. When you fetch it back it will be the same without extra deserialization code needing to be written. However, if your code has a datatype that the db doesn't support that is another matter.
							2. Typically the db will auto-create table/collections as soon as a write command is executed on them
							3. Typically any schema object can be inserted. This means the app devs can change the schema without DBA requests.
							4. Queries are with objects (this case a simple 'fieldX = valueY' rule by way of map with a single key->value pair) of the programming language
							5. The results come back as a native object. Not a record tuple type which is a little bit more verbose
						</aside>
					</section>
				</section>

				<section><!-- Object Stores -->
					<section>
						<h1>Object Stores</h1>
					</section>
					<section>
						<pre><code>
							import xyz_cloudapi_lib
							client = xyz_cloudapi_lib.connect() â‘ 
							client.auth(client_key: xxxx, secret: â€¦...) â‘¡
							obj_api = client.api_select('object_store') â‘¢â€‹
							foo_bucket = obj_api.select_bucket('foo') â‘£â€‹
							foo_bucket.upload_object(path: 'app_foo/records/' + x.id, x.serialize()) â‘¤ â‘¥ â‘¦
							y = deserialize(foo_bucket.get_object(path: app_foo/records/' + y_id)) â‘¥ â‘§
						</code></pre>
						<aside class="notes">
							1. You're making a HTTP connection and every operation is a HTTP request. So firstly each request is slower than a db driver like ODBC or mongo wire protocol. Secondly Error handling will be HTTP error handling, or getting a well-formed but proprietary error response to parse and deal with.â€‹
							2. Stricter authentication at the base level; no simple username+password option
							3. Might be one of many services in a cloud provider
							4. Buckets. Equivalent organizational entity to collection/tables.
							5. You need to choose a key/path for each object. Need to share that same logic amongst all app code.
							6. You have to serialize and deserialize the objects. Some common formats such as JSON will have simple ways to do it though
							7. No object format (schema control) enforced by the API
							8. There is no query support such 'find objects with field_A = value_X'. You can only retrieve or update by the primary key.
							(Amazon's S3 Select, Athena or Redshift are layers on top of S3 that run close to S3 object storage servers, they are not object stores themself.)
						</aside>
					</section>
				</section>

				<section><!-- Key-value -->
					<section>
						<h1>Key-value</h1>
					</section>
					<section>
						<pre><code>
							import xyz_kv_lib
							db = xyz_kv_lib.connect(dbname=business_app_foo, user=appservice_acct_pqr) â‘ 
							x = { id: "HSE-18414513", child_recs: [ "a", "b", c"], created: date.now() } â‘¡
							db.set(x.id, serialize(x)); â‘¡ â‘¢
							y = deserialize(db.get("MER-27620021")) â‘¡ â‘¢â€‹
							db.delete("xxx-â€¦.") â‘¢â€‹
							csr = db.list_keys() â‘¢ â‘£â€‹
							for k in csr: do â€¦. â‘£
						</code></pre>
						<aside class="notes">
							1. The context object could be a single namespace or a table, it varies between different servers
							2. Use your own objects. But stereotypically you have to serialize and deserialize them; and if the objects are complex then there will be migration complexity - old records have the old format, new ones have the new, how to detect, update policy? Etc.
							3. set(), get(), delete(), list_keys() is all there is the idealized KV server
							4. There is no general query syntax to use to find values with property x or property y. There is only fetching by key, or iterating all keys.
						</aside>
					</section>
				</section>

				<section><!-- Timeseries db -->
					<section>
						<h1>Timeseries database</h1>
					</section>
					<section>
						<pre><code>
							//Data is typically inserted by other continuously-running services â‘ â€‹
							import xyz_tsdb_lib
							tsdb_conn = tsdb.open(host_url) â‘¡â€‹
							ts_span = [ Date("2023-03-24T08:55:00Z"), Date("2023-03-24T09:00:00Z") ] â‘¢â€‹
							resolution = "10s" â‘¢â€‹
							qry = 'rate(metric_abc{host="foo"})' â‘£â€‹
							ts_qry_result = tsdb_conn.query(ts_span, resolution, qry) â‘¢â€‹
							print(ts_qry_result) â‘¤â€‹
							> [ [1679648100, 4562], [1679648110, 1040], [1679648120, 3890],  â€¦ , [1679648390, 8261], [1679648400, 7342] ]
						</code></pre>
						<aside class="notes">
							1. As mentioned in the comment. Because monitoring seems to be the most common
							2. There are both HTTP and custom or ODBC db drive type connections. The HTTP ones don't seem require auth by default. At least the ones typically used for monitoring.
							3. A time range to query on and the resolution (interval) to return the timeseries samples is always required.
							4. There is query syntax. Aggregations on counter or gauge timeseries values. Often much more complex than this example.
							5. The result is an array of &lt;timestamp&gt;, &lt;value&gt; pairs. The timestamp is forced to be round steps by resolution argument and the values likewise - either latest-before value, nearest value, extrapolated value between two nearest samples, etc.
						</aside>
					</section>
				</section>

				<section><!-- Graph dbs -->
					<section>
						<h1>Graph database</h1>
					</section>
					<section>
						<pre><code>
							// Connection etc. The same as SQL or a document db API
							// DBA prior task: "CREATE NODE_TYPE Person (...); CREATE NODE_TYPE Team (â€¦); CREATE EDGE_TYPE TeamMembership (â€¦); CREATE GRAPH OrgChart (Person, TeamMembership, Team)" â‘ 
							p1 = [10320, "smith", "john"]
							db.execute("INSERT Person (%s, %s, %s)", new_p) â‘¡â€‹
							t1 = ["ACME", "UK", "Risk"]
							db.execute("INSERT TeamMembership(%s, %s, %s)", p1.id, t1)) â‘¢â€‹
							person_cur = db.execute('SELECT Person-[TeamMembership]->Team(%s)', t1); â‘£â€‹
							print(person_cur.fetchone())
							> (10414, "kelly", "jane")
						</code></pre>
						<aside class="notes">
							1. ???
							2. ????
							3. ???
							4. ???
						</aside>
					</section>
				</section>

				<section><!-- Embedded Storage Engine -->
					<section>
						<h1>Embedded Storage Engine</h1>
					</section>
					<section>
						<p>If the application ...</p>
						<ul>
							<li>Doesn't share data with other instances</li>
							<li>Doesn't require durability guarantees above that of the local filesystem</li>
							<li>A minimal query engine functionality is acceptable</li>
						</ul>
						<p>... it could use a storage engine, embedded in itself, instead of connecting to an external datastore</p>
					</section>
					<section>
						<pre><code>
							.... TODO ....
						</code></pre>
					</section>
				</section>

				<section><!-- "Pros and cons" -->
					<h1>Pros and Cons of different API types</h1>
				</section>

				<section><!-- Schema freedom -->
					<h2>Schema freedom</h2>
				</section>
				<section>
					<p>Some datastores restrict the schema, some don't.</p>
					<p>Unknown field &RightArrow; Reject &RightArrow; client runtime error</p>
					<p>vs.</p>
					<p>Unknown field &RightArrow; Accept&semi;<br>Surprise new field for other clients</p>
					<aside class="notes">
						If applications insert a record that has an unknown field or is missing a field that is mandatory the entire request will be rejected and exception sent back to the client application.
						Relational databases are well-known for popularizing schema control.
					</aside>
				</section>
				<section>
					<h4>Positives of server-side locked schema</h4>
					<ul>
						<li>Guarantees that all applications connecting to the same backend datastore obey a single schema orthodoxy</li>
					</ul>
				</section>
				<section>
					<h4>Negatives of server-side locked schema</h4>
					<p>Schema changes time-consuming</p>
					<ul>
						<li>Some downtime usually required</li>
						<li>App devs and DBA teams need to work in sync.<br>
							(Typically adds many weeks to releases)</li>
					</ul>
				</section>
				<section>
					<h4>Schema-enforcing datastores</h4>
					<ul>
						<li>Relational databases</li>
						<li>Graph</li>
						<li class="na_ish">Timeseries</li>
					</ul>
				</section>
				<section>
					<h4>Schema-free datastores</h4>
					<p>(as commonly used, at least)</p>
					<ul>
						<li>Document databases</li>
						<li class="na_ish">Object stores</li>
						<li class="na_ish">Key-value</li>
						<li class="na_ish">Block / file</li>
					</ul>
				</section>

				</section>

				<section><!-- Complex query language -->
					<h2>Complexity level of API</h2>
				</section>
				<section>
					<h3>Simple functionality in datastore</h3>
					<p>Example: Classic, spartan key-value store</p>
					<p>Only four commands &ndash; PUT, GET, DELETE and LIST</p>
					<p>Keys and values are binary, need deserialization in the app</p>
					<p>Application developer obliged to code everything beyond single-record processing</p>
				</section>
				<section>
					<h3>Complex functionality in datastore</h3>
					<p>Example: RDBMS with fully-evolved SQL syntax suport. Stored Procedures. Secondary indexes. Query plan optimizations</p>
				</section>

				<section><!-- Connections -->
					<h2>Connections</h2>
				</section>

				<section>
					<h3>Connection behaviour</h3>
					<p>The behaviour of an APIs client-server connections is an important feature.</p>
				</section>
				<section>
					<p>Connection behaviour is a different dimension to the code:</p>
					<ul>
						<li>You don't program it</li>
						<li>The client API either supports some connection mode or it doesn't.</li>
						<li>Using different modes is more often a matter of config files rather than code lines.</li>
					</ul>
				</section>
				<section>
					<p>Reading the previous slide the app developer might feel <i>"I'm powerless here; I'll skip thinking about it for now."</i></p>
					<p>Don't do that!</p>
				</section>
				<section>
					<p>Be aware of what you get with different client APIs - what they support significantly changes the way the application is managed in live operation / meets business requirements.</p>
				</section>

				<section>
					<h3>Connection Protocols</h3>
					<p>The type of network protocol a database / datastore client API uses affects</p>
					<ul>
						<li>Performance</li>
						<li>Failure response</li>
					</ul>
				</section>
				<section>
					<p>Connections that stay open provide the best latency. No need to reestablish TCP connection or authentication context for each request sent. Multiple-operation transactions can be performed because the client connection has enough state.</p>
				</section>
				<section>
					<p>Requests that use a new connection each time can be run without holding a TCP socket open indefinitely while the app runs. Less state allows broader network scenarios, eg. SaaS backends behind load balancers.</p>
				</section>
				<section>
					<p>Client APIs that have automatic failover (eg. old primary lost, finds new primary automatically) provide a large benefit for business continuity goals. Options to auto-retry interrupted requests save the app developer from writing a lot of error handling.</p>
				</section>
				<section>
					<ul>
						<li>Custom wire protocol over TCP</li>
						<li>HTTP1.x</li>
						<li>HTTP2 Streaming</li>
						<ul>
							<li>GRPC</li>
						</ul>
					</ul>
				</section>
				<section>
					<p>Databases that have replication (primary+secondaries, or 'multi-master', or master+slave, main+standby, etc) often support rolling restart procedures. <b>This is a very important cost-of-operations advantage.</b></p>
					<p>If the client API seamlessly switches to new primary as the role changes during maintenance restarts you gain a huge operational advantage: DBAs can do maintenance such as upscaling to new servers, upgrading versions etc. without shutting down the frontend application. I.e. without stopping the business or dragging the app dev team into the task.</p>
				</section>
				<section>
					<h2>Connection Security</h2>
					<ul>
						<li>Network encryption</li>
						<li>Authentication</li>
						<ul>
							<li>Classic account name + password</li>
							<li>Certificate</li>
							<li>Federated Authentication</li>
						</ul>
					</ul>
				</section>


				<section><!-- Client-side encryption -->
					<h1>Client-side encryption</h1>
				</section>
				<section>
					<p>To protect against information theft an application can store already-encrypted data in the database / datastore. Hacking the database server, or its backups, becomes pointless.</p>
					<p>Something to consider for applications that have security requirements so high they can't even trust the DBA team / DBAAS provider.</p>
					<p>Storing encrypted data makes the database 'dumber' though. Eg. querying a record set by range X1 to X2 cannot use efficient index lookup if "X" is an encrypted value</p>
				</section>
				<section>
					<p>A few database APIs have added the crypto functions to the database API itself. This is an alternative to using a general-purpose crypto library to manually do the encryption and decryption steps.</p>
					<p>The API cannot auto-magic the work away though. The tech debt rises just as much as if you do manual encryption. The main burden is the key management, i.e. the IT security team needs to manage the certs and distribute new and periodically renewed certs to the application servers, and the application team have to work with them when they do that.</p>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)"><!-- Summary -->
					<h1>Summary</h1>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore APIs ...</p>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore APIs ...</p>
					<p>differ more than you realize.</p>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore API choice exists!</p>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore API choice exists!</p>
					<p>Big differences in:</p>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore API choice exists!</p>
					<p>Big differences in:</p>
					<ul>
						<li>App development ease</li>
					</ul>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore API choice exists!</p>
					<p>Big differences in:</p>
					<ul>
						<li>App development ease</li>
						<li>Deployment ease</li>
					</ul>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore API choice exists!</p>
					<p>Big differences in:</p>
					<ul>
						<li>App development ease</li>
						<li>Deployment ease</li>
						<li>Uptime guarantees</li>
					</ul>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>Datastore API choice does NOT exist after</p>
					<p>the backend datastore has been chosen.</p>
				</section>

				<section data-background-gradient="radial-gradient(#283b95, #17b2c3)" data-auto-animate>
					<p>So before a datastore is decided in a new project<br>
						DON'T WASTE OPPORTUNITY<br>
						to judge datastores by client API style as well.</p>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealHighlight, RevealNotes ],
			});
		</script>
	</body>
</html>
